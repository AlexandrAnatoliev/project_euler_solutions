// main.c - problem 61 (project Euler)
// Цикличные фигурные числа

// К фигурным (многоугольным) числам относятся треугольные, квадратные, пятиугольные, шестиугольные, 
// семиугольные и восьмиугольные числа, которые расчитываются по следующим формулам:

// Треугольные	 	P3, n = n(n + 1) / 2	 	1, 3, 6, 10, 15, ...
// Квадратные	 	P4, n = n2	 				1, 4, 9, 16, 25, ...
// Пятиугольные	 	P5, n = n(3n−1) / 2	 		1, 5, 12, 22, 35, ...
// Шестиугольные	P6, n = n(2n−1)	 			1, 6, 15, 28, 45, ...
// Семиугольные	 	P7, n = n(5n−3) / 2	 		1, 7, 18, 34, 55, ...
// Восьмиугольные	P8, n = n(3n−2)	 			1, 8, 21, 40, 65, ...

// Упорядоченное множество из трех четырехзначных чисел : 8128, 2882, 8281, 
// обладает тремя интересными свойствами
//
// Множество является цикличным : последние две цифры каждого числа являются первыми двумя цифрами 
// следующего(включая последнее и первое числа).
// Каждый тип многоугольника — треугольник(P3, 127 = 8128), квадрат(P4, 91 = 8281) 
// и пятиугольник(P5, 44 = 2882) — представлены различными числами данного множества.
// Это — единственное множество четырехзначных чисел, обладающее указанными свойствами.
// Найдите сумму элементов единственного упорядоченного множества из шести цикличных четырехзначных чисел,
// в котором каждый тип многоугольников — треугольник, квадрат, пятиугольник, шестиугольник, 
// семиугольник и восьмиугольник — представлены различными числами этого множества.
//

#include <stdio.h>
#include "header.h"
#include "timer.h"
#include "funcs.c"

int main(void)
{
	TIMER_START

	//	инициализация первого узла первым 4-значным треугольным числом (близким к 1000)
	
	//	добавление и инициализация остальных узлов в список
	//	сохранить первый узел (треугольное число) и последний (восьмиугольное)
    //  TODO зачем? конец списка можно определить по NULL
	// 
	//	пока треугольное число не превысит 9999 
	// 
	//		если конец цепочки (next == NULL)
	//			сравнить цифры первого и последнего числа
	//				если совпали break;
	//
	//		если число - фигурное
	//			GET_FIGURE(number, name) == value
	//			увеличиваем его
	//		иначе
	//			получаем ближайшее к value
	//		
	//		если узел не первый (head != NULL)
	//			и число вышло за диапазон из 100 (меньше (head->value%100) * 100 + 100)
	//				идем влево
	//		иначе если узел последний
	//			continue
	//		иначе
	//			присваиваем следующему числу новое значение 1234->3400
	//			переходим вправо
	//
	//		
	//	TODO цифры могут случайно совпась на любой паре 1234 (треугольное) и 3456 (квадратное)
	//		но 3456 не является первым числом, нужно искать ближайшее к 3400 
	//		иначе можно пропустить возможную цепочку
	// 
	//	вычисление ответа
	
	// удаление списка и освобождение памяти

	//	инициализация первого узла первым 4-значным треугольным числом (близким к 1000)
	//	добавление и инициализация остальных узлов в список
	//	сохранить первый узел (треугольное число) и последний (восьмиугольное)
    //  TODO зачем? конец списка можно определить по NULL
	// 
	//	пока треугольное число не превысит 9999 
	// 
	//		если конец цепочки (next == NULL)
	//			сравнить цифры первого и последнего числа
	//				если совпали break;
	//
	//		если число - фигурное
	//			GET_FIGURE(number, name) == value
	//			увеличиваем его
	//		иначе
	//			получаем ближайшее к value
	//		
	//		если узел не первый (head != NULL)
	//			и число вышло за диапазон из 100 (меньше (head->value%100) * 100 + 100)
	//				идем влево
	//		иначе если узел последний
	//			continue
	//		иначе
	//			присваиваем следующему числу новое значение 1234->3400
	//			переходим вправо
	//
	//		
	//	TODO цифры могут случайно совпась на любой паре 1234 (треугольное) и 3456 (квадратное)
	//		но 3456 не является первым числом, нужно искать ближайшее к 3400 
	//		иначе можно пропустить возможную цепочку
	// 
	//	вычисление ответа
	
	// удаление списка и освобождение памяти

	TIMER_FINISH
    SHOW_TIME
	// вывод ответа
	return 0;
}